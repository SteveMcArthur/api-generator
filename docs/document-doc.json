{"text":"Docpad Lib","id":"root","children":[{"id":"G0","text":"DocumentModel","typ":"class","icon":"class","comments":["Necessary","Optional","Local","---------------------------------","Document Model",""],"code":[],"children":[{"id":"G1","text":"klass","typ":"prop","icon":"prop","comments":["---------------------------------","Properties","","Model Class"],"code":["DocumentModel"],"children":[]},{"id":"G2","text":"type","typ":"string","icon":"string","comments":["Model Type"],"code":["'document'"],"children":[]},{"id":"G3","text":"defaults","typ":"prop","icon":"prop","comments":["---------------------------------","Attributes",""],"code":["extendr.extend({}, FileModel"],"children":[{"id":"G4","text":"referencesOthers","typ":"prop","icon":"prop","comments":["---------------------------------","Special variables","","outExtension","The final extension used for our file","Takes into accounts layouts","\"layout.html\", \"post.md.eco\" -> \"html\"","already defined in file.coffee","","Whether or not we reference other doucments"],"code":["false"],"children":[]},{"id":"G5","text":"header","typ":"prop","icon":"prop","comments":["---------------------------------","Content variables","","The file meta data (header) in string format before it has been parsed"],"code":["null"],"children":[]},{"id":"G6","text":"parser","typ":"prop","icon":"prop","comments":["The parser to use for the file's meta data (header)"],"code":["null"],"children":[]},{"id":"G7","text":"body","typ":"prop","icon":"prop","comments":["The file content (body) before rendering, excludes the meta data (header)"],"code":["null"],"children":[]},{"id":"G8","text":"rendered","typ":"prop","icon":"prop","comments":["Have we been rendered yet?"],"code":["false"],"children":[]},{"id":"G9","text":"contentRendered","typ":"prop","icon":"prop","comments":["The rendered content (after it has been wrapped in the layouts)"],"code":["null"],"children":[]},{"id":"G10","text":"contentRenderedWithoutLayouts","typ":"prop","icon":"prop","comments":["The rendered content (before being passed through the layouts)"],"code":["null"],"children":[]},{"id":"G11","text":"render","typ":"prop","icon":"prop","comments":["---------------------------------","User set variables","","Whether or not we should render this file"],"code":["true"],"children":[]},{"id":"G12","text":"renderSingleExtensions","typ":"prop","icon":"prop","comments":["Whether or not we want to render single extensions"],"code":["false","\t})","",""],"children":[]}]},{"id":"G13","text":"getOutContent","typ":"method","icon":"method","comments":["---------------------------------","Helpers","","Get Out Content"],"code":["\t\tcontent = @get('contentRendered') or @getContent()","\t\treturn content",""],"children":[]},{"id":"G14","text":"referencesOthers","typ":"method","icon":"method","comments":["References Others"],"code":["\t\tflag ?= true","\t\t@set({referencesOthers:flag})","\t\t@","",""],"children":[]},{"id":"G15","text":"parse","typ":"prop","icon":"prop","comments":["---------------------------------","Actions","","Parse","Parse our buffer and extract some meaningful data from it","next(err)"],"code":["(opts={},next) ->","\t\t[opts,next] = extractOptsAndCallback(opts,next)","\t\tbuffer = @getBuffer()","","\t\tsuper opts, =>","\t\t\t# Prepare","\t\t\tmeta = @getMeta()","\t\t\tmetaDataChanges = {}","\t\t\tparser = header = body = content = null","","\t\t\t# Content","\t\t\tcontent = @get('content').replace(/\\r\\n?/gm,'\\n')  # normalise line endings for the web, just for convience, if it causes problems we can remove","","\t\t\t# Header","\t\t\tregex = ///","\t\t\t\t# allow some space","\t\t\t\t^\\s*","","\t\t\t\t# allow potential comment characters in seperator","\t\t\t\t[^\\n]*?","","\t\t\t\t# discover our seperator characters","\t\t\t\t(","\t\t\t\t\t([^\\s\\d\\w])  #\\2","\t\t\t\t\t\\2{2,}  # match the above (the first character of our seperator), 2 or more times","\t\t\t\t) #\\1","","\t\t\t\t# discover our parser (optional)","\t\t\t\t(?:","\t\t\t\t\t\\x20*  # allow zero or more space characters, see https://github.com/jashkenas/coffee-script/issues/2668","\t\t\t\t\t(","\t\t\t\t\t\t[a-z]+  # parser must be lowercase alpha","\t\t\t\t\t)  #\\3","\t\t\t\t)?","","\t\t\t\t# discover our meta content","\t\t\t\t(","\t\t\t\t\t[\\s\\S]*?  # match anything/everything lazily","\t\t\t\t) #\\4","","\t\t\t\t# allow potential comment characters in seperator","\t\t\t\t[^\\n]*?","","\t\t\t\t# match our seperator (the first group) exactly","\t\t\t\t\\1","","\t\t\t\t# allow potential comment characters in seperator","\t\t\t\t[^\\n]*","\t\t\t\t///","","\t\t\t# Extract Meta Data","\t\t\tmatch = regex.exec(content)","\t\t\tif match","\t\t\t\t# TODO: Wipe the old meta data","","\t\t\t\t# Prepare","\t\t\t\tseperator = match[1]","\t\t\t\tparser = match[3] or 'yaml'","\t\t\t\theader = match[4].trim()","\t\t\t\tbody = content.substring(match[0].length).trim()","","\t\t\t\t# Parse","\t\t\t\ttry","\t\t\t\t\tswitch parser","\t\t\t\t\t\twhen 'cson', 'coffee', 'coffeescript', 'coffee-script', 'json'","\t\t\t\t\t\t\tCSON = require('cson')  unless CSON","\t\t\t\t\t\t\tmetaParseResult = CSON.parseSync(header)","\t\t\t\t\t\t\textendr.extend(metaDataChanges, metaParseResult)","","\t\t\t\t\t\twhen 'yaml'","\t\t\t\t\t\t\tYAML = require('yamljs')  unless YAML","\t\t\t\t\t\t\tmetaParseResult = YAML.parse(","\t\t\t\t\t\t\t\theader.replace(/\\t/g,'    ')  # YAML doesn't support tabs that well","\t\t\t\t\t\t\t)","\t\t\t\t\t\t\textendr.extend(metaDataChanges, metaParseResult)","","\t\t\t\t\t\telse","\t\t\t\t\t\t\terr = new Error(\"Unknown meta parser: #{parser}\")","\t\t\t\t\t\t\treturn next(err)","\t\t\t\tcatch err","\t\t\t\t\treturn next(err)","\t\t\telse","\t\t\t\tbody = content","","\t\t\t# Incorrect encoding detection?","\t\t\t# If so, re-parse with the correct encoding conversion","\t\t\tif metaDataChanges.encoding and metaDataChanges.encoding isnt @get('encoding')","\t\t\t\t@set({encoding:metaDataChanges.encoding})","\t\t\t\topts.reencode = true","\t\t\t\treturn @parse(opts, next)","","\t\t\t# Update meta data","\t\t\tbody = body.replace(/^\\n+/,'')","\t\t\t@set(","\t\t\t\tsource: content","\t\t\t\tcontent: body","\t\t\t\theader: header","\t\t\t\tbody: body","\t\t\t\tparser: parser","\t\t\t\tname: @get('name') or @get('title') or @get('basename')","\t\t\t)","","\t\t\t# Correct data format","\t\t\tmetaDataChanges.date = new Date(metaDataChanges.date)   if metaDataChanges.date","","\t\t\t# Correct ignore","\t\t\tfor key in ['ignore','skip','draft']","\t\t\t\tif metaDataChanges[key]?","\t\t\t\t\tmetaDataChanges.ignored = (metaDataChanges[key] ? false)","\t\t\t\t\tdelete metaDataChanges[key]","\t\t\tfor key in ['published']","\t\t\t\tif metaDataChanges[key]?","\t\t\t\t\tmetaDataChanges.ignored = !(metaDataChanges[key] ? false)","\t\t\t\t\tdelete metaDataChanges[key]","","\t\t\t# Handle urls","\t\t\t@addUrl(metaDataChanges.urls)  if metaDataChanges.urls","\t\t\t@setUrl(metaDataChanges.url)   if metaDataChanges.url","","\t\t\t# Check if the id was being over-written","\t\t\tif metaDataChanges.id?","\t\t\t\t@log 'warn', \"\"\"","\t\t\t\t\tThe document #{@getFilePath()} tried to over-write its `id` attribute with its meta-data.","\t\t\t\t\tThis will cause unexpected issues. We have ignored the `id` attribute changes to prevent further errors.","\t\t\t\t\tWe recommend you rename the `id` meta-data attribute on this document to something else.","\t\t\t\t\tFor more information, see: https://github.com/bevry/docpad/issues/742","\t\t\t\t\t\"\"\"","\t\t\t\tdelete metaDataChanges.id","","\t\t\t# Apply meta data","\t\t\t@setMeta(metaDataChanges)","","\t\t\t# Next","\t\t\treturn next()","","\t\t@",""],"children":[]},{"id":"G16","text":"normalize","typ":"prop","icon":"prop","comments":["Prepare","Reparse the data and extract the content","With the content, fetch the new meta data, header, and body","Chain","Normalize data","Normalize any parsing we have done, as if a value has updates it may have consequences on another value. This will ensure everything is okay.","next(err)"],"code":["(opts={},next) ->","\t\t[opts,next] = extractOptsAndCallback(opts,next)","\t\tchanges = {}","\t\tmeta = @getMeta()","","\t\toutExtension = opts.outExtension or meta.get('outExtension') or null","\t\tfilename = opts.filename or @get('filename') or null","\t\textensions = @getExtensions({filename}) or null","","\t\tif !outExtension","\t\t\tchanges.outExtension = outExtension = extensions[0] or null","","\t\tsuper(extendr.extend(opts, changes), next)","","\t\t@",""],"children":[]},{"id":"G17","text":"contextualize","typ":"prop","icon":"prop","comments":["Prepare","Extract","Extension Rendered","Forward","Chain","Contextualize data","Put our data into perspective of the bigger picture. For instance, generate the url for it's rendered equivalant.","next(err)"],"code":["(opts={},next) ->","\t\t[opts,next] = extractOptsAndCallback(opts,next)","","\t\t@getEve (err,eve) =>","\t\t\t# Prepare","\t\t\treturn next(err)  if err","\t\t\tchanges = {}","\t\t\tmeta = @getMeta()","","\t\t\t# User specified","\t\t\toutFilename = opts.outFilename or meta.get('outFilename') or null","\t\t\toutPath = opts.outPath or meta.get('outPath') or null","\t\t\toutExtension = opts.outExtension or meta.get('outExtension') or null","\t\t\textensions = @getExtensions({filename:outFilename}) or null","","\t\t\t# outExtension","\t\t\tif !outExtension","\t\t\t\tif !outFilename and !outPath","\t\t\t\t\tif eve?","\t\t\t\t\t\tchanges.outExtension = outExtension = eve.get('outExtension') or extensions[0] or null","\t\t\t\t\telse","\t\t\t\t\t\tchanges.outExtension = extensions[0] or null","","\t\t\t# Forward onto normalize to adjust for the outExtension change","\t\t\treturn @normalize(extendr.extend(opts, changes), next)","","\t\t@","",""],"children":[]},{"id":"G18","text":"hasLayout","typ":"method","icon":"method","comments":["Prepare","Get our highest ancestor","Chain","---------------------------------","Layouts","","Has Layout","Checks if the file has a layout"],"code":["\t\treturn @get('layout')?",""],"children":[]},{"id":"G19","text":"getLayout","typ":"method","icon":"method","comments":["Get Layout","The layout object that this file references (if any)","We update the layoutRelativePath as it is used for finding what documents are used by a layout for when a layout changes","next(err, layout)"],"code":["\t\tfile = @","\t\tlayoutSelector = @get('layout')","","\t\treturn next(null, null)  unless layoutSelector","","\t\t@emit 'getLayout', {selector:layoutSelector}, (err,opts) ->","\t\t\t# Prepare","\t\t\t{layout} = opts","","\t\t\t# Error","\t\t\tif err","\t\t\t\tfile.set('layoutRelativePath': null)","\t\t\t\treturn next(err)","","\t\t\t# Not Found","\t\t\telse unless layout","\t\t\t\tfile.set('layoutRelativePath': null)","\t\t\t\treturn next()","","\t\t\t# Found","\t\t\telse","\t\t\t\tfile.set('layoutRelativePath': layout.get('relativePath'))","\t\t\t\treturn next(null, layout)","","\t\t@",""],"children":[]},{"id":"G20","text":"getEve","typ":"method","icon":"method","comments":["Prepare","Check","Find parent","Chain","Get Eve","Get the most ancestoral layout we have (the very top one)","next(err,layout)"],"code":["\t\tif @hasLayout()","\t\t\t@getLayout (err,layout) ->","\t\t\t\tif err","\t\t\t\t\treturn next(err, null)","\t\t\t\telse if layout","\t\t\t\t\tlayout.getEve(next)","\t\t\t\telse","\t\t\t\t\tnext(null, null)","\t\telse","\t\t\tnext(null, @)","\t\t@","",""],"children":[]},{"id":"G21","text":"renderExtensions","typ":"prop","icon":"prop","comments":["---------------------------------","Rendering","","Render extensions","next(err,result)"],"code":["(opts,next) ->","\t\tfile = @","\t\t[opts,next] = extractOptsAndCallback(opts, next)","\t\t{content,templateData,renderSingleExtensions} = opts","\t\textensions = @get('extensions')","\t\tfilename = @get('filename')","\t\tfilePath = @getFilePath()","\t\tcontent ?= @get('body')","\t\ttemplateData ?= {}","\t\trenderSingleExtensions ?= @get('renderSingleExtensions')","","\t\tresult = content","","\t\textensionsReversed = []","\t\tif extensions.length is 0 and filename","\t\t\textensionsReversed.push(filename)","\t\tfor extension in extensions","\t\t\textensionsReversed.unshift(extension)","","\t\tif renderSingleExtensions and extensionsReversed.length is 1","\t\t\tif renderSingleExtensions isnt 'auto' or filename.replace(/^\\./,'') is extensionsReversed[0]","\t\t\t\textensionsReversed.push(null)","","\t\treturn next(null, result)  if extensionsReversed.length <= 1","","\t\ttasks = new TaskGroup \"renderExtensions: #{filePath}\", next:(err) ->","\t\t\t# Forward with result","\t\t\treturn next(err, result)","","\t\teachr extensionsReversed[1..], (extension,index) ->","\t\t\t# Task","\t\t\ttasks.addTask \"renderExtension: #{filePath} [#{extensionsReversed[index]} => #{extension}]\", (complete) ->","\t\t\t\t# Prepare","\t\t\t\t# eventData must be defined in the task","\t\t\t\t# definining it in the above loop will cause eventData to persist between the tasks... very strange, but it happens","\t\t\t\t# will cause the jade tests to fail","\t\t\t\teventData =","\t\t\t\t\tinExtension: extensionsReversed[index]","\t\t\t\t\toutExtension: extension","\t\t\t\t\ttemplateData: templateData","\t\t\t\t\tfile: file","\t\t\t\t\tcontent: result","","\t\t\t\t# Render","\t\t\t\tfile.trigger 'render', eventData, (err) ->","\t\t\t\t\t# Check","\t\t\t\t\treturn complete(err)  if err","","\t\t\t\t\t# Check if the render did anything","\t\t\t\t\t# and only check if we actually have content to render!","\t\t\t\t\t# if this check fails, error with a suggestion","\t\t\t\t\tif result and (result is eventData.content)","\t\t\t\t\t\tmessage = \"\\n  Rendering the extension \\\"#{eventData.inExtension}\\\" to \\\"#{eventData.outExtension}\\\" on \\\"#{file.attributes.relativePath}\\\" didn't do anything.\\n  Explanation here: http://docpad.org/extension-not-rendering\"","\t\t\t\t\t\tfile.log('warn', message)","\t\t\t\t\t\treturn complete()","","\t\t\t\t\t# The render did something, so apply and continue","\t\t\t\t\tresult = eventData.content","\t\t\t\t\treturn complete()","","\t\ttasks.run()","","\t\t@","",""],"children":[]},{"id":"G22","text":"renderDocument","typ":"prop","icon":"prop","comments":["Prepare","Prepare result","Prepare extensions","If we want to allow rendering of single extensions, then add null to the extension list","If we only have one extension, then skip ahead to rendering layouts","Prepare the tasks","Cycle through all the extension groups and render them","Run tasks synchronously","Chain","Render Document","next(err,result)"],"code":["(opts,next) ->","\t\tfile = @","\t\t[opts,next] = extractOptsAndCallback(opts, next)","\t\t{content,templateData} = opts","\t\textension = @get('extensions')[0]","\t\tcontent ?= @get('body')","\t\ttemplateData ?= {}","","\t\teventData = {extension,templateData,file,content}","","\t\tfile.trigger 'renderDocument', eventData, (err) ->","\t\t\t# Forward","\t\t\treturn next(err, eventData.content)","","\t\t@","",""],"children":[]},{"id":"G23","text":"renderLayouts","typ":"prop","icon":"prop","comments":["Prepare","Prepare event data","Render via plugins","Chain","Render Layouts","next(err,result)"],"code":["(opts,next) ->","\t\tfile = @","\t\t[opts,next] = extractOptsAndCallback(opts, next)","\t\t{content,templateData} = opts","\t\tcontent ?= @get('body')","\t\ttemplateData ?= {}","","\t\tfile.getLayout (err, layout) ->","\t\t\t# Check","\t\t\treturn next(err, content)  if err","","\t\t\t# We have a layout to render","\t\t\tif layout","\t\t\t\t# Assign the current rendering to the templateData.content","\t\t\t\ttemplateData.content = content","","\t\t\t\t# Merge in the layout meta data into the document JSON","\t\t\t\t# and make the result available via documentMerged","\t\t\t\t# templateData.document.metaMerged = extendr.extend({}, layout.getMeta().toJSON(), file.getMeta().toJSON())","","\t\t\t\t# Render the layout with the templateData","\t\t\t\tlayout.clone().action 'render', {templateData}, (err,result) ->","\t\t\t\t\treturn next(err, result)","","\t\t\t# We had a layout, but it is missing","\t\t\telse if file.hasLayout()","\t\t\t\t\terr = new Error(\"Could not find the specified layout: #{layoutSelector}\")","\t\t\t\t\treturn next(err, content)","","\t\t\t# We never had a layout","\t\t\telse","\t\t\t\treturn next(null, content)","",""],"children":[]},{"id":"G24","text":"render","typ":"prop","icon":"prop","comments":["Prepare","Grab the layout","Render","Render this file","next(err,result,document)"],"code":["(opts={},next) ->","\t\t[opts,next] = extractOptsAndCallback(opts, next)","\t\tfile = @","","\t\tcontentRenderedWithoutLayouts = null","\t\trelativePath = file.get('relativePath')","","\t\topts = extendr.clone(opts or {})","\t\topts.actions ?= ['renderExtensions', 'renderDocument', 'renderLayouts']","\t\tif opts.apply?","\t\t\terr = new Error(\"The `apply` option when rendering documents is now deprecated. Use `document.clone().action('render', ...)` instead\")","\t\t\treturn next(err)","","\t\topts.content ?= file.get('body')","","\t\topts.templateData = extendr.clone(opts.templateData or {})  # deepClone may be more suitable","\t\topts.templateData.document ?= file.toJSON()","\t\topts.templateData.documentModel ?= file","","\t\tfor own key, value of opts.templateData","\t\t\tif value?.bind is Function::bind  # we do this style of check, as underscore is a function that has it's own bind","\t\t\t\topts.templateData[key] = value.bind(opts.templateData)","","\t\tfile.log 'debug', \"Rendering the file: #{relativePath}\"","","\t\ttasks = new TaskGroup \"render tasks for: #{relativePath}\", next:(err) ->","\t\t\t# Error?","\t\t\tif err","\t\t\t\tfile.log 'warn', \"Something went wrong while rendering: #{relativePath}\\n#{err.stack or err.message or err}\"","\t\t\t\treturn next(err, opts.content, file)","","\t\t\t# Attributes","\t\t\tcontentRendered = opts.content","\t\t\tcontentRenderedWithoutLayouts ?= contentRendered","\t\t\trendered = true","\t\t\tfile.set({contentRendered, contentRenderedWithoutLayouts, rendered})","","\t\t\t# Log","\t\t\tfile.log 'debug', \"Rendering completed for: #{relativePath}\"","","\t\t\t# Apply","\t\t\tfile.attributes.rtime = new Date()","","\t\t\t# Success","\t\t\treturn next(null, opts.content, file)","\t\t\t# ^ do not use super here, even with =>","\t\t\t# as it causes layout rendering to fail","\t\t\t# the reasoning for this is that super uses the document's contentRendered","\t\t\t# where, with layouts, opts.apply is false","\t\t\t# so that isn't set","","\t\tif 'renderExtensions' in opts.actions","\t\t\ttasks.addTask \"renderExtensions: #{relativePath}\", (complete) ->","\t\t\t\tfile.renderExtensions opts, (err,result) ->","\t\t\t\t\t# Check","\t\t\t\t\treturn complete(err)  if err","","\t\t\t\t\t# Apply the result","\t\t\t\t\topts.content = result","","\t\t\t\t\t# Done","\t\t\t\t\treturn complete()","","\t\tif 'renderDocument' in opts.actions","\t\t\ttasks.addTask \"renderDocument: #{relativePath}\", (complete) ->","\t\t\t\tfile.renderDocument opts, (err,result) ->","\t\t\t\t\t# Check","\t\t\t\t\treturn complete(err)  if err","","\t\t\t\t\t# Apply the result","\t\t\t\t\topts.content = result","\t\t\t\t\tcontentRenderedWithoutLayouts = result","","\t\t\t\t\t# Done","\t\t\t\t\treturn complete()","","\t\tif 'renderLayouts' in opts.actions","\t\t\ttasks.addTask \"renderLayouts: #{relativePath}\", (complete) ->","\t\t\t\tfile.renderLayouts opts, (err,result) ->","\t\t\t\t\t# Check","\t\t\t\t\treturn complete(err)  if err","","\t\t\t\t\t# Apply the result","\t\t\t\t\topts.content = result","","\t\t\t\t\t# Done","\t\t\t\t\treturn complete()","","\t\ttasks.run()","","\t\t@","",""],"children":[]},{"id":"G25","text":"writeSource","typ":"prop","icon":"prop","comments":["Prepare","Prepare variables","Options","Prepare content","Prepare templateData","Ensure template helpers are bound correctly","Prepare result","file.set({contentRendered:null, contentRenderedWithoutLayouts:null, rendered:false})","","Log","Prepare the tasks","Render Extensions Task","Render Document Task","Render Layouts Task","Fire the tasks","Chain","---------------------------------","CRUD","","Write the file","next(err)"],"code":["(opts,next) ->","\t\t[opts,next] = extractOptsAndCallback(opts, next)","\t\tfile = @","","\t\topts.content ?= (@getContent() or '').toString('')","","\t\tCSON      = require('cson')  unless CSON","\t\tmetaData  = @getMeta().toJSON(true)","\t\tdelete metaData.writeSource","\t\tcontent   = body = opts.content.replace(/^\\s+/,'')","\t\theader    = CSON.stringifySync(metaData)","\t\tif !header or header is '{}'","\t\t\t# No meta data","\t\t\tsource    = body","\t\telse","\t\t\t# Has meta data","\t\t\tparser    = 'cson'","\t\t\tseperator = '###'","\t\t\tsource    = \"#{seperator} #{parser}\\n#{header}\\n#{seperator}\\n\\n#{body}\"","","\t\topts.content = source","","\t\tsuper(opts, next)","","\t\t@","",""],"children":[]}]}]}